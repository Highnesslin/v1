---
title: The Three-Component Problem
description: Is this the limit of React composability?
date: 2024-04-10
authors: [pomber]
draft: true
---

There's an interesting problem I'm facing with React.

## Some context

I'm building a library for syntax highlighting. The library allows you to override a couple of things with components. For example, you can **override how a line looks**:

{/* prettier-ignore */}
```jsx user-code.jsx
import { Code } from "library"

function MyCode(props) {
  return <Code {...props} components={{ Line: MyLine }} />
}

function MyLine({ lineNumber, children, ...props }) {
  return <div {...props}>{lineNumber} - {children}</div>
}
```

The library supports annotations. Annotations use components to change how a line looks or behave.

{/* prettier-ignore */}
```jsx user-code.jsx
function MyCode(props) {
  return <Code {...props}
    components={{ Line: MyLine, RightBorder, BackgroundHover }}
  />
}

function RightBorder(props) {
  const [size, setSize] = useState(1)
  return <MyLine {...props}
    onClick={() => setSize(size + 1)}
    style={{ borderRight: `${size}px solid green` }}
  />
}

function BackgroundHover(props) {
  // don't do this at home, use CSS instead
  const [hover, setHover] = useState(false) 
  return <MyLine {...props}
    onMouseEnter={() => setHover(true)} 
    onMouseLeave={() => setHover(false)}
    className={hover ? "bg-blue-600" : "bg-red-600"} 
  />
}
```

Demo of this working

````mdx content.md
```js
function lorem(ipsum) {
  // BackgroundHover(1:2)
  console.log(1)
  console.log(2)
  console.log(3)
  // RightBorder(1:2)
  console.log(3)
  console.log(4)
}
```
````

The `Code` component that handles this could be something like this:

```jsx library.jsx
function Code({ components, ...props }) {
  const lines = extractLinesAndAnnotations(props)
  return <pre>{lines.map((line) => renderLine({ components, ...line }))}</pre>
}

function renderLine({ components, annotation, children, lineNumber }) {
  const Component = components[annotation] || components.Line
  return <Component lineNumber={lineNumber}>{children}</Component>
}
```

Notice how we have `annotation` (singular) and not `annotations` (plural).

## The three-component problem

But what happens when we have two annotations applied to the same line?

How can we make a component that is `MyLine`, `BackgroundHover`, and `RightBorder` at the same time?

This is the three-component problem.

## Making the API composable

We need an API that can handle stacking annotations.

One option is to pass a `ChildLine` component as a prop:

{/* prettier-ignore */}
```jsx
function RightBorder({ ChildLine, ...props }) {
  const [size, setSize] = useState(1)
  return <ChildLine {...props}
    onClick={() => setSize(size + 1)}
    style={{ borderRight: `${size}px solid green` }}
  />
}
```

From the `RightBorder` point of view, `ChildLine` could be `MyLine`, `BackgroundHover`, or whatever other annotation we add in the future.

## Implementing the new API

We can rewrite the `renderLine` function to accept a stack of annotations instead of just one, and pass the `ChildLine` prop:

```jsx library.jsx
function renderLine({ components, annotations, children, lineNumber }) {
  const Line = annotations.reduce((ChildLine, annotation) => {
    const Component = components[annotation]
    return Component
      ? (props) => <Component {...props} ChildLine={ChildLine} />
      : ChildLine
  }, components.Line)
  return <Line lineNumber={lineNumber}>{children}</Line>
}
```

There's a bug in this code. Can you spot it?

````mdx content.md
```js
function lorem(ipsum) {
  // BackgroundHover(1:5)
  console.log(1)
  console.log(2)
  // RightBorder(1:2)
  console.log(3)
  console.log(4)
  console.log(5)
}
```
````

Since we are using `useState` in the `RightBorder` component, the `size` state will be reset every time the `RightBorder` component is rendered. This is because the `RightBorder` component is being re-created every time `renderLine` is called.

### Extra complexity

Things we left out but are important:

- It's not just lines, other components can be overridden and annotated too (tokens, token groups, line groups, pre blocks, etc).
- We can't call the components as functions. Components may use hooks.
- Should also work for RSC. Components can be `async`.
- Ideally should also support `forwardRef`.

## My Solution

Calculate and memoize all permutations ahead of time

-

## Questions for you

- How would you render the line for the given API
- How would you redesign the API?

Playground: https://codesandbox.io/p/sandbox/the-three-component-problem-pzp523?file=%2Fsrc%2Flibrary.js%3A4%2C2
