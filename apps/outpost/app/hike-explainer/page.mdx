import { Hike } from "codehike"
import { ExplainerLayout } from "./hike"
import { ChevronsDown } from "lucide-react"

<Hike as={ExplainerLayout}>

# Code Hike v1.0<span className="text-sky-200">\*</span>: new markdown API

<span className="text-sky-200 text-2xl opacity-80">

\*under development and open for feedback

</span>

## ! bottom-16 w-56 mx-auto inset-x-0 text-center

Scroll down

<ChevronsDown
  className="mx-auto -mt-4"
  size={28}
/>

```mdx
{/* !from ./snipets/00.start.mdx */}
```

```jsx
// !from ./snipets/00.start.jsx
```

## ! top-48 inset-x-0 mx-auto w-72

Code Hike v1.0 will introduce a <code style={{color: "rgb(255, 203, 107)"}}>{`<Hike/>`}</code> component that enables the definition of content with a complex structure in plain markdown.

```mdx
{/* !Focus(1,5:9) */}
{/* !from ./snipets/00.hike.mdx */}
```

```jsx
// !Focus(2[1])
// !from ./snipets/00.hike.jsx
```

## ! top-60 right-40 w-60

The processed content is then passed as props to a custom React component that you define.

```mdx
{/* !Focus(2,6) */}
{/* !from ./snipets/00.layout.mdx */}
```

```jsx
// !Focus(1,7)
// !from ./snipets/00.layout.jsx
```

## ! top-72 right-24 w-60

Any plain content inside <code style={{color: "rgb(255, 203, 107)"}}>{`<Hike/>`}</code> will be passed inside the <code style={{color: "rgb(240, 113, 120)"}}>children</code> prop.

```mdx
{/* !Mark(8) */}
{/* !Focus(6:10) */}
{/* !from ./snipets/00.children.mdx */}
```

```jsx
// !Mark(9)
// !Focus(7:11)
// !from ./snipets/00.children.jsx
```

## ! top-52 left-48 w-72

Any header that starts with <code style={{color: "rgb(255, 203, 107)"}}>!</code> defines a new section. The word after <code style={{color: "rgb(255, 203, 107)"}}>!</code> will be the name of the section, in this case <code style={{color: "rgb(255, 203, 107)"}}>steps</code>.

```mdx
{/* !Focus(7[1:9],11[1:9]) */}
{/* !from ./snipets/01.steps.mdx */}
```

```jsx
// !Focus(2[1])
<>
  <h1>Hello World</h1>
  <MyLayout
    data={{
      children: <p>zero</p>,
      steps: [
        {
          query: "one 1",
          children: <p>uno</p>
        },
        {
          query: "two 2",
          children: <p>dos</p>
        }
      ]
    }}
  />
</>
```

## ! top-40 right-20 w-48

Sections are passed to the layout component as arrays grouped by name.

```mdx
{/* !Focus(7[1:9],11[1:9]) */}
{/* !from ./snipets/01.steps.mdx */}
```

```jsx
// !Focus(4,6,15,16)
<>
  <h1>Hello World</h1>
  <MyLayout
    data={{
      children: <p>zero</p>,
      steps: [
        {
          query: "one 1",
          children: <p>uno</p>
        },
        {
          query: "two 2",
          children: <p>dos</p>
        }
      ]
    }}
  />
</>
```

## ! top-48 left-48 w-72

The rest of the header becomes the <code style={{color: "rgb(240, 113, 120)"}}>query</code> property.

The content of the section is passed in the <code style={{color: "rgb(240, 113, 120)"}}>children</code> property.

```mdx
{/* !Mark(7:10) */}
{/* !Focus(7:14) */}
{/* !from ./snipets/01.steps.mdx */}
```

```jsx
// !Mark(7:10)
// !Focus(6:15)
<>
  <h1>Hello World</h1>
  <MyLayout
    data={{
      children: <p>zero</p>,
      steps: [
        {
          query: "one 1",
          children: <p>uno</p>
        },
        {
          query: "two 2",
          children: <p>dos</p>
        }
      ]
    }}
  />
</>
```

## ! top-12 left-48 w-72

You can nest sections using **deeper headers**.

Here, <code style={{color: "rgb(255, 203, 107)"}}>### !steps one and a half</code> will be inside <code style={{color: "rgb(255, 203, 107)"}}>## !steps one 1</code>.

```mdx
{/* !Mark(9:12) */}
{/* !Focus(5,9:12) */}
{/* !from ./snipets/01.nested.mdx */}
```

```jsx
// !Mark(9:12)
// !Focus(4,6,8:13,16)
// !from ./snipets/01.nested.jsx
```

## ! top-64 left-48 w-60

You can have sections with different names too.

```mdx
{/* !Mark(5:8) */}
{/* !Focus(5:8) */}
{/* !from ./snipets/01.names.mdx */}
```

```jsx
// !Mark(4:9)
// !Focus(4:9)
<MyLayout
  data={{
    children: <p>zero</p>,
    foo: [
      {
        query: "lorem ipsum",
        children: <p>bar</p>
      }
    ],
    steps: [
      {
        query: "one 1",
        children: <p>uno</p>
      }
    ]
  }}
/>
```

## ! top-56 left-48 w-60

Code blocks are also processed, and passed to the component as <code style={{color: "rgb(240, 113, 120)"}}>code</code> sections.

```mdx
{/* !Mark(5:7) */}
{/* !Focus(5:11) */}
{/* !from ./snipets/02.code.mdx */}
```

```jsx
// !Mark(5:9)
// !Focus(4:15)
// !from ./snipets/02.code.jsx
```

## !footer

## Notes

- You will be able to copy-paste common layouts from the Code Hike website (_a la_ [shadcn/ui](https://ui.shadcn.com/)) and customize them to your needs.
- Code Hike will also provide components and utilities, the building blocks for your layouts.
- The layout component can be a React Server Component (that runs at build-time), this gives us a lot of flexibility to manipulate the content data before rendering it.
- It will be possible to use it without React Server Components. Code Hike will pre-process the content data before passing it to the layout component (for example, syntax highlighting code blocks). But this loses some flexibility.

## !footer

## Feedback

This is a work in progress, and I'd love to hear your feedback. The most useful feedback right now is giving me more use cases so I can build more proofs of concept that will help define:

- the shape of the content data object
- the building blocks provided by Code Hike
- the reference layouts
- the markdown API

So, **what kind of layouts would you like to be able to create with this API?** You can [open a discussion in this repo](https://github.com/code-hike/v1/discussions), any feedback is welcome.

Follow [@pomber](https://twitter.com/pomber) for updates. Send me a DM if you are interested in early access.

</Hike>
